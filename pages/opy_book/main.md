---
Copyright: (C) Ryuichi Ueda
---

# the opy book

## 1. はじめに

　opy（オーピーワイ、あるいはオーパイ）は、ワンライナーでPythonを使うためのラッパーコマンドです。Pythonワンライナーで面倒となるテキストの読み込み処理などを暗黙理に行うほか、代表的な行指向言語であるAWKの「パターン/アクション」を取り入れることで、Pythonの文法やライブラリを使った簡潔なワンライナーを書くことを可能にしました。

　このドキュメントは、opyについて網羅的に書いた入門書になることを目指しているものです。まだ書きかけですが、現時点では唯一の入門書です。

### 1.1 opyを立ち上げる

　opyは、リポジトリ https://github.com/ryuichiueda/opy に置いてあります。インストール方法はこのリポジトリの`README.md`に書いてあります。

　opyをインストールしたら、`opy`と打ってみましょう。


```
opy 1.9.3

Copyright 2019 Ryuichi Ueda
Released under MIT license
https://github.com/ryuichiueda/opy

You are using Python 3.7.4 with this command.
```

このようにopyのバージョンやコピーライト、ライセンスの情報が出力されます。また、opyはPythonのラッパーなので、出力の最下行のように、Pythonのバージョンも出力されます。これにより、どのバージョンのPythonの文法や機能が利用できるかを把握できます。


　次に、お約束のHello worldを出力してみましょう。次のように様々な方法がありますが、詳細の説明は次章以降にします。

```
$ echo Hello world | opy '[F0]'
Hello world
$ echo Hello world | opy '[F1,F2]'
Hello world
$ echo Hello world | opy '{print(F0)}'
Hello world
$ opy 'B:["Hello world"]'
Hello world
```

## 2. レコードとアクション

### 2.1 （ノーマル）アクション

　**アクション**は、opyの中で最もPythonと似ている機能です。例えば、次の例は、`seq`から読み込んだ数字に2をかけて出力するという単純なものです。

```
$ seq 3
1
2
3
$ seq 3 | opy '{print(F1*2)}'
2
4
6
```

引数の`{print(F1*2)}`がアクションです。`{ }`の中にPythonの文を書くと、文が毎行の入力に対して適用されます。`F1`は毎行で読み込んだ数字が格納された変数ですが、これは後で説明します。

### 2.2 リストアクション

　実は、上の例は

```
$ seq 3 | opy '[F1*2]'
2
4
6
```

と、もっと短く書けます。`[ ]`はPythonのリストを表し、`opy`は`{...}`の代わりにリストを書いておくと、そのままリストの内容を出力します。この表記を、**リストアクション**と呼びます。また、リストアクションと区別したいときは、`{...}`の表記を使うアクションを**ノーマルアクション**と呼びます。


### 2.3 レコードとフィールド

### 2.3.1 予約変数F1, F2, ...

　先ほどの`F1`は、「（各行の）1列目」を表します。`opy`は標準入力から行を読み込むと、空白を見つけて自動で分割し、`F1, F2, ...`という変数に割り当てます。これは、AWKにおける`$1, $2, ...`を真似たものです。「`F`」は「**フィールド**」の頭文字をとったものです。また、opyやAWKでは、入力される毎行のデータを「**レコード**」と呼びます。


　2個以上のフィールドを持つデータを扱ってみましょう。次のようなデータを`seq`と`xargs`で作ります。

```
$ seq 10 | xargs -n 5
1 2 3 4 5
6 7 8 9 10
```

この出力について、例えば`F3`の数だけを2で割って出力したければ、

```
$ seq 10 | xargs -n 5 | opy '[F3/2]'
1.5
4.0
```

という表記になります。また、他のフィールドも出力したいのであれば、

```
$ seq 10 | xargs -n 5 | opy '[F1,F2,F3/2,F4,F5]'
1 2 1.5 4 5
6 7 4.0 9 10
```

というようにリストに他のフィールドを加えるとよいのですが、これは後でもっと短い書き方ができるようになります。

　本項の例のように、標準入力から読み込まれたデータは、フィールドに分解されるときに自動的にint型あるいはfloat型に変換されます。例を示します。

```
$ echo 1 1.1 aaa | opy '[type(F1), type(F2), type(F3)]' 
<class 'int'> <class 'float'> <class 'str'>
```

この仕様には欠点もあり、次のような型に関するバグの原因となります。

```
$ echo 1 1.1 aaa | opy '[F1+F3]'
（エラー）
```

上の例の場合、`F1`を文字列型に直す必要があります。

```
$ echo 1 1.1 aaa | opy '[str(F1)+F3]'
1aaa
```

### 2.3.2 予約変数F0

　`F0`は、行全体の情報を持った変数です。

```
$ echo 1 1.1 aaa | opy '[F0]'
1 1.1 aaa
$ echo "1 1.1      aaa" | opy '[F0]'
1 1.1      aaa
```

これも、AWKの変数`$0`を真似たものです。


　`F0`の型は常に文字列型です。次の例は、`F0`と`F1`の違いを表したものです。

```
$ echo 1 | opy '[F0*10, F1*10]'
1111111111 10
```


## 3. パターンによる検索

　opyは、AWKのように`grep`の拡張版として利用することができます。たとえば、次の例は`seq 5`の結果から偶数の行を検索するものです。

```
$ seq 5
1
2
3
4
5
$ seq 5 | opy 'F1%2==0'
2
4
```


　`opy`に引数として与えた`F1%2==0`のことを「パターン」と呼びます。パターンにはboolを返す式を記述できます。いくつか例を示します。

```
### F1の文字列の長さが3のものを検索 ###
$ cat hoge
aaa bb
ccccc d
eeee fffff
$ cat hoge | opy 'len(F1)==3'
aaa bb
### 2以上4未満を検索 ###
$ seq 5 | opy '2<=F1<4'
2
3
### 5つの数字が全て異なる行を出力 ###
$ cat nums 
1 2 3 4 5
2 3 3 5 4
1 2 2 3 3
uedambp2:R2_KAKEN ueda$ cat nums | opy 'len(set(F[1:]))==5'
1 2 3 4 5
```

　最後の行の`F[1:]`は、1列目以降のデータが入ったリストです。

## 4. リストアクション
