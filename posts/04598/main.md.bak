# 開眼シェルスクリプト2013年7月号
出典: 技術評論社SoftwareDesign<br />
 <br />
 <div class="section" id="cgi1"><br />
<h1>19. 開眼シェルスクリプト 第19回 シェルスクリプトでCGIスクリプト1<a class="headerlink" href="#cgi1" title="このヘッドラインへのパーマリンク">¶</a></h1><br />
<p>　今回から何回かは、連載当初からいつかやるはめになると考えていた<br />
CGIスクリプトを作るというお題を扱います。</p><br />
<p>　CGIというのは common gateway interface の略で、<br />
単純に言うとブラウザから<br />
ウェブサーバに置いてあるプログラムを起動するための仕様です。<br />
CGIという言葉は interface を指すので、<br />
CGIで動く（動かされる）プログラムのことは、<br />
CGIプログラムと言ったりCGIスクリプトと言ったりする方が丁寧です。<br />
スクリプト言語で書いた場合はCGIスクリプトと言うのがよいでしょう。</p><br />
<p>　CGIプログラムは、どんな言語で作っても構いません。<br />
C言語で書いても良いわけですが、<br />
この領域ではlightweight language（LL言語）で書かれることがほとんどであり、<br />
伝統的にはperl、php、最近ではruby、pythonもよく使われます。</p><br />
<p>　そこにシェルスクリプトを加えてやろうというのが今回から数回の内容です。<br />
シェルスクリプトは簡単にOSのコマンドが使えるので大丈夫かいなとよく言われます。<br />
確かにウェブでデータをやりとりするという目的に比べると、<br />
シェルスクリプトでできることはそれを遥かに超越しており、<br />
しかも文字数少なく邪悪なことができてしまいます。<br />
<tt class="docutils literal"><span class="pre">rm</span> <span class="pre">-Rf</span> <span class="pre">/</span></tt> （8文字！）とか。</p><br />
<p>　しかし、「インジェクションを食らいやすいかどうか」という観点においては、<br />
気をつけていれば言語レベルでは他の言語と大差なく、<br />
むしろ食らいにくいんじゃないかなと筆者は考えています。<br />
世間での書き方のガイドラインが未成熟なだけで、<br />
シェルスクリプトでCGIをやると危ないというのは短絡的で相手を知らなさすぎます。<br />
食わず嫌いはいけません。</p><br />
<p>　「女をよくいうひとは、女を十分知らないものであり、女をいつも悪くいう人は、<br />
女を全く知らないものである。」<br />
&#8212; モーリス・ルブラン「怪盗アルセーヌ・ルパン」</p><br />
<p>　 <tt class="docutils literal"><span class="pre">sed</span> <span class="pre">'s/女/シェルスクリプト/g'</span></tt> して音読してから、<br />
先にお進みください。</p><br />
<div class="section" id="apache"><br />
<h2>19.1. Apacheを準備<a class="headerlink" href="#apache" title="このヘッドラインへのパーマリンク">¶</a></h2><br />
<p>　今回想定する環境はbash、Apache が動くUNIX系の環境です。<br />
筆者は手元で動かしたいので今回もMacを使います。<br />
Linuxで動かす場合については情報が大量にweb上にあるので、<br />
ここで説明しなくても大丈夫でしょう。</p><br />
<p>　筆者もこれを執筆中に初めて知ったのですが、<br />
OS Xには最初からapache がバンドルされていて、<br />
すぐ使えるようになっています。</p><br />
<p>　リスト1のようにコマンドを打つと、apacheが起動します。</p><br />
<ul class="simple"><br />
<li>リスト1: apacheを立ち上げる</li><br />
</ul><br />
<div class="highlight-bash"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1<br />
2<br />
3<br />
4<br />
5<br />
6</pre></div></td><td class="code"><div class="highlight"><pre>uedamac:apache2 ueda<span class="nv">$ </span>sudo -s<br />
bash-3.2# apachectl start<br />
org.apache.httpd: Already loaded<br />
bash-3.2# ps cax | grep httpd<br />
16023 ?? Ss 0:00.15 httpd<br />
16024 ?? S 0:00.00 httpd<br />
</pre></div><br />
</td></tr></table></div><br />
<p>　本連載の読者ならば、動作確認はブラウザじゃなくて<br />
リスト2のようにcurlでやりましょう。</p><br />
<ul class="simple"><br />
<li>リスト2: curlで動作確認</li><br />
</ul><br />
<div class="highlight-bash"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1<br />
2</pre></div></td><td class="code"><div class="highlight"><pre>uedamac:apache2 ueda<span class="nv">$ </span>curl http://localhost<br />
&lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;<br />
</pre></div><br />
</td></tr></table></div><br />
<p>　次に、リスト3のように、cgiを置くディレクトリを確認します。<br />
CGIプログラムは <tt class="docutils literal"><span class="pre">cgi-bin</span></tt> というところに置く事が多いので、<br />
<tt class="docutils literal"><span class="pre">cgi-bin</span></tt> で設定ファイル（ <tt class="docutils literal"><span class="pre">httpd.conf</span></tt> ）を検索します。<br />
検索はエディタを開いて、そのエディタの機能で行っても構いません。<br />
ただ、こういった記事や説明手順を書くときは、<br />
シェルの操作を行ったような体裁の方が分かりやすく書けます。<br />
さっきのcurlも、ブラウザのスクリーンショットを掲載するより楽です。<br />
きっとコミュニケーションのコストに違いがあるのでしょう。<br />
案外大事な余談でした。</p><br />
<ul class="simple"><br />
<li>リスト3: <tt class="docutils literal"><span class="pre">cgi-bin</span></tt> の場所を調査</li><br />
</ul><br />
<div class="highlight-bash"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1<br />
2<br />
3<br />
4<br />
5<br />
6</pre></div></td><td class="code"><div class="highlight"><pre>uedamac:~ ueda<span class="nv">$ </span>apachectl -V | grep conf<br />
 -D <span class="nv">SERVER_CONFIG_FILE</span><span class="o">=</span><span class="s2">&quot;/private/etc/apache2/httpd.conf&quot;</span><br />
<br />
uedamac:~ ueda<span class="nv">$ </span>cat /private/etc/apache2/httpd.conf | grep cgi-bin<br />
 ScriptAliasMatch ^/cgi-bin/<span class="o">((</span>?!<span class="o">(</span>?i:webobjects<span class="o">))</span>.*<span class="nv">$)</span> <span class="s2">&quot;/Library/WebServer/CGI-Executables/$1&quot;</span><br />
<span class="c">#ErrorDocument 404 &quot;/cgi-bin/missing_handler.pl&quot;</span><br />
</pre></div><br />
</td></tr></table></div><br />
<p>　確認の結果、 <tt class="docutils literal"><span class="pre">/Library/WebServer/CGI-Executables/</span></tt> という、<br />
きったねえ名前のディレクトリで動くことが分かりました。<br />
今回は大変遺憾ですが、ここにCGIスクリプトを置く事にします。<br />
いちいちこのディレクトリを覚えておくのは面倒なので、<br />
リスト4のように自分のホームの下にシンボリックリンクを張りましょう。<br />
どうせ自分しか使わないので、所有者も変えておきます。</p><br />
<ul class="simple"><br />
<li>リスト4: ホームから簡単にアクセスできるようにする</li><br />
</ul><br />
<div class="highlight-bash"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1<br />
2<br />
3</pre></div></td><td class="code"><div class="highlight"><pre>uedamac:~ ueda<span class="nv">$ </span>ln -s /Library/WebServer/CGI-Executables/ ./cgi-bin<br />
uedamac:~ ueda<span class="nv">$ </span><span class="nb">cd </span>cgi-bin<br />
uedamac:cgi-bin ueda<span class="nv">$ </span>sudo chown ueda:wheel ./<br />
</pre></div><br />
</td></tr></table></div><br />
</div><br />
<div class="section" id="cgi"><br />
<h2>19.2. CGIプログラムとはなんぞや？=&gt;ただのプログラム<a class="headerlink" href="#cgi" title="このヘッドラインへのパーマリンク">¶</a></h2><br />
<p>　さあ作業開始です。最初にやるのはCGIプログラムを動かすことです。<br />
CGIプログラムと聞くと何か特別なものだと考えている人が多いので、<br />
その誤解を解いておきましょう。ちょっとした実験をします。</p><br />
<p>　まず、 <tt class="docutils literal"><span class="pre">/tmp/</span></tt> の下に <tt class="docutils literal"><span class="pre">hoge</span></tt> というファイルを作り、<br />
所有者をapacheの実行ユーザに変えておきます。<br />
apacheの実行ユーザ、そしてグループはリスト5のように調査できます。</p><br />
<ul class="simple"><br />
<li>リスト5: apacheの動作するユーザ、グループを調査</li><br />
</ul><br />
<div class="highlight-bash"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1<br />
2<br />
3<br />
4</pre></div></td><td class="code"><div class="highlight"><pre>uedamac:~ ueda<span class="nv">$ </span>grep ^User /private/etc/apache2/httpd.conf<br />
User _www<br />
uedamac:~ ueda<span class="nv">$ </span>grep ^Group /private/etc/apache2/httpd.conf<br />
Group _www<br />
</pre></div><br />
</td></tr></table></div><br />
<p>リスト6のように <tt class="docutils literal"><span class="pre">hoge</span></tt> を置きましょう。</p><br />
<ul class="simple"><br />
<li>リスト6: ファイルを置いてapacheから操作できるように所有者変更</li><br />
</ul><br />
<div class="highlight-bash"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1<br />
2</pre></div></td><td class="code"><div class="highlight"><pre>uedamac:cgi-bin ueda<span class="nv">$ </span>touch /tmp/hoge<br />
uedamac:cgi-bin ueda<span class="nv">$ </span>sudo chown _www:_www /tmp/hoge<br />
</pre></div><br />
</td></tr></table></div><br />
<p>次に、リスト7のように <tt class="docutils literal"><span class="pre">rm</span></tt> コマンドを <tt class="docutils literal"><span class="pre">cgi-bin</span></tt> の下に置きます。<br />
拡張子は <tt class="docutils literal"><span class="pre">.cgi</span></tt> にしておきます。</p><br />
<ul class="simple"><br />
<li>リスト7: <tt class="docutils literal"><span class="pre">rm</span></tt> コマンドに拡張子をつけて <tt class="docutils literal"><span class="pre">cgi-bin</span></tt> に置く</li><br />
</ul><br />
<div class="highlight-bash"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre>uedamac:~ ueda<span class="nv">$ </span>cp /bin/rm ~/cgi-bin/rm.cgi<br />
</pre></div><br />
</td></tr></table></div><br />
<p>では、この <tt class="docutils literal"><span class="pre">rm.cgi</span></tt> を、ブラウザで呼び出してみます。<br />
これは <tt class="docutils literal"><span class="pre">curl</span></tt> を使うと雰囲気が出ないので、ブラウザで。<br />
アドレスの欄には、<br />
<tt class="docutils literal"><span class="pre">http://localhost/cgi-bin/rm.cgi?/tmp/hoge</span></tt> と書きます。</p><br />
<p>　ブラウザに表示されるのは、残念ながら図1のような<br />
Internal Server Error です。</p><br />
<ul class="simple"><br />
<li>図1: <tt class="docutils literal"><span class="pre">rm.cgi</span></tt> を実行した結果</li><br />
</ul><br />
<div class="figure"><br />
<a class="reference internal image-reference" href="http://blog.ueda.asia/wp-content/uploads/2014/12/RM_CGI.png"><img alt="" src="http://blog.ueda.asia/wp-content/uploads/2014/12/RM_CGI.png" style="width: 30%;" /></a><br />
</div><br />
<p>しかし、 <tt class="docutils literal"><span class="pre">/tmp/hoge</span></tt> は、リスト8のように消えています。</p><br />
<ul class="simple"><br />
<li>リスト8: <tt class="docutils literal"><span class="pre">/tmp/hoge</span></tt> が消える</li><br />
</ul><br />
<div class="highlight-bash"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1<br />
2</pre></div></td><td class="code"><div class="highlight"><pre>uedamac:cgi-bin ueda<span class="nv">$ </span>ls /tmp/hoge<br />
ls: /tmp/hoge: No such file or directory<br />
</pre></div><br />
</td></tr></table></div><br />
<p>びっくりしましたでしょうか？</p><br />
<p>　結局、何をやったかというと、<br />
ブラウザに <tt class="docutils literal"><span class="pre">http://localhost/cgi-bin/rm.cgi?/tmp/hoge</span></tt><br />
を指定することで、サーバ（この例では自分のMac）の<br />
<tt class="docutils literal"><span class="pre">cgi-bin</span></tt> の下の <tt class="docutils literal"><span class="pre">rm.cgi</span></tt> のオプションに、<br />
<tt class="docutils literal"><span class="pre">/tmp/hoge</span></tt> を渡して <tt class="docutils literal"><span class="pre">/tmp/hoge</span></tt> を消したということになります。<br />
<tt class="docutils literal"><span class="pre">ssh</span></tt> でリモートのサーバに対し、</p><br />
<div class="highlight-bash"><div class="highlight"><pre><span class="nv">$ </span>ssh &lt;ホスト&gt; <span class="s1">&#39;~/cgi-bin/rm.cgi /tmp/hoge&#39;</span><br />
</pre></div><br />
</div><br />
<p>とやることと何ら変わりがありません。<br />
違うのは、22番ポートでなく、80番ポートを使用したくらいです。</p><br />
<p>　ただし、 <tt class="docutils literal"><span class="pre">rm</span></tt> コマンドをインターネット上から<br />
不特定多数の人にやられたらたまったものではないので、<br />
apacheでは、</p><br />
<ul class="simple"><br />
<li>UserやGroupで実行するユーザを限定</li><br />
<li>実行できるプログラムを特定のディレクトリの下のものに制限</li><br />
<li>拡張子を登録した物だけに制限</li><br />
</ul><br />
<p>するなど、一定の制約を設けてなるべく安全にしてあります。</p><br />
<p>　逆に、 <tt class="docutils literal"><span class="pre">~/cgi-bin/</span></tt> の下に置いて実行可能なようにパーミッションを設定すれば、<br />
プログラムはなんでもCGIで起動できるようになります。<br />
<tt class="docutils literal"><span class="pre">rm.cgi</span></tt> のようにC言語で書いてあっても、<br />
伝統的に perl で書いても動きます。</p><br />
<p>　・・・ということは、シェルスクリプトでも動くということになります。</p><br />
</div><br />
<div class="section" id="id1"><br />
<h2>19.3. CGIシェルスクリプトを書く<a class="headerlink" href="#id1" title="このヘッドラインへのパーマリンク">¶</a></h2><br />
<p>　では、シェルスクリプトでCGIスクリプトを書いてみましょう。<br />
まず、ブラウザに字を表示するための最小限のCGIスクリプトをリスト9に示します。</p><br />
<ul class="simple"><br />
<li>リスト9: 最小限のCGIスクリプト</li><br />
</ul><br />
<div class="highlight-bash"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1<br />
2<br />
3<br />
4<br />
5<br />
6<br />
7<br />
8</pre></div></td><td class="code"><div class="highlight"><pre>uedamac:cgi-bin ueda<span class="nv">$ </span>cat smallest.cgi<br />
<span class="c">#!/bin/bash -xv</span><br />
<br />
<span class="nb">echo</span> <span class="s2">&quot;Content-Type: text/html&quot;</span><br />
<span class="nb">echo</span> <span class="s2">&quot;&quot;</span><br />
<span class="nb">echo</span> 魚眼perlスクリプト<br />
//書いたら実行できるようにしておきましょう。<br />
uedamac:cgi-bin ueda<span class="nv">$ </span>chmod +x smallest.cgi<br />
</pre></div><br />
</td></tr></table></div><br />
<p>　このシェルスクリプトは何の変哲もないものなので、<br />
リスト10のように普通に端末から実行できます。</p><br />
<ul class="simple"><br />
<li>リスト10: 端末からCGIスクリプトを実行してみる</li><br />
</ul><br />
<div class="highlight-bash"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1<br />
2<br />
3<br />
4</pre></div></td><td class="code"><div class="highlight"><pre>uedamac:cgi-bin ueda<span class="nv">$ </span>./smallest.cgi 2&gt; /dev/null<br />
Content-Type: text/html<br />
<br />
魚眼perlスクリプト<br />
</pre></div><br />
</td></tr></table></div><br />
<p>　何の変哲もないのですが、ブラウザから呼び出すと図2のように見えます。</p><br />
<ul class="simple"><br />
<li>図2: ブラウザから <tt class="docutils literal"><span class="pre">smallest.cgi</span></tt> を実行した結果</li><br />
</ul><br />
<div class="figure"><br />
<a class="reference internal image-reference" href="http://blog.ueda.asia/wp-content/uploads/2014/12/SMALLEST.png"><img alt="" src="http://blog.ueda.asia/wp-content/uploads/2014/12/SMALLEST.png" style="width: 50%;" /></a><br />
</div><br />
<p>　この例のポイントはいくつかあります。<br />
まず、 <tt class="docutils literal"><span class="pre">Content-Type-type:</span> <span class="pre">text/html</span></tt> ですが、<br />
これはHTTPプロトコルで定められたHTTPヘッダです。<br />
さきほどの <tt class="docutils literal"><span class="pre">rm.cgi</span></tt> でブラウザにエラーが出たのは、<br />
HTTPヘッダを <tt class="docutils literal"><span class="pre">rm.cgi</span></tt> が出さないからです。<br />
ブラウザとapacheはHTTPプロトコルでしゃべっているので、<br />
apache（が動かしているCGIプログラム）<br />
がHTTPヘッダを返さず、ブラウザが怒ったのでした。</p><br />
<p>　ヘッダの次の <tt class="docutils literal"><span class="pre">echo</span> <span class="pre">&quot;&quot;</span></tt> は、<br />
ヘッダと中身を区切る空白行を出すためにあります。<br />
ヘッダの前には余計なものを出してはいけないので、<br />
例えばリスト11のようなCGIスクリプトをブラウザから呼び出すと、<br />
やはりブラウザにエラーが表示されます。</p><br />
<ul class="simple"><br />
<li>リスト11: HTTPヘッダの前に何か出力するとエラーになる</li><br />
</ul><br />
<div class="highlight-bash"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1<br />
 2<br />
 3<br />
 4<br />
 5<br />
 6<br />
 7<br />
 8<br />
 9<br />
10<br />
11</pre></div></td><td class="code"><div class="highlight"><pre>uedamac:cgi-bin ueda<span class="nv">$ </span>cat dame.cgi<br />
<span class="c">#!/bin/bash -xv</span><br />
<br />
<span class="nb">echo </span>huh?<br />
<span class="nb">echo</span> <span class="s2">&quot;Content-Type: text/html&quot;</span><br />
<span class="nb">echo</span> <span class="s2">&quot;&quot;</span><br />
<span class="nb">echo</span> 湾岸pythonスクリプト<br />
uedamac:cgi-bin ueda<span class="nv">$ </span>curl http://localhost/cgi-bin/dame.cgi 2&gt; /dev/null | head -n 3<br />
&lt;!DOCTYPE HTML PUBLIC <span class="s2">&quot;-//IETF//DTD HTML 2.0//EN&quot;</span>&gt;<br />
&lt;html&gt;&lt;head&gt;<br />
&lt;title&gt;500 Internal Server Error&lt;/title&gt;<br />
</pre></div><br />
</td></tr></table></div><br />
<p>　この例では <tt class="docutils literal"><span class="pre">Content-Type-type:</span> <span class="pre">text/html</span></tt> と、<br />
「テキストのHTML」を送ると言っておいて、<br />
実際には単なる一行のテキストしか送っていませんが、<br />
これは今のところこだわらないでおきましょう。</p><br />
<p>　次に着目すべきは、シェルスクリプトはただ標準出力に字を出しているだけで、<br />
ブラウザやウェブサーバに何か特別なことをしているわけではないということです。<br />
これはapacheがシェルスクリプトの出力を受け取ってブラウザに投げるからです。<br />
シェルスクリプトの側ですべきことは、<br />
正確なHTTPヘッダの出力だけということになります。<br />
いかにもUNIXらしい動きです。</p><br />
<p>　最後、シバン（ <tt class="docutils literal"><span class="pre">#!/bin/bash</span></tt> ）の行にログを出力する <tt class="docutils literal"><span class="pre">-vx</span></tt><br />
というオプションをつけましたが、このログはどこに行くのか。<br />
実はリスト12のように、apacheのエラーログに行きます。</p><br />
<ul class="simple"><br />
<li>リスト12: <tt class="docutils literal"><span class="pre">error_log</span></tt> にCGIスクリプトの標準エラー出力がたまる</li><br />
</ul><br />
<div class="highlight-bash"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1<br />
2<br />
3<br />
4<br />
5<br />
6<br />
7<br />
8<br />
9</pre></div></td><td class="code"><div class="highlight"><pre>uedamac:cgi-bin ueda<span class="nv">$ </span>cat /private/var/log/apache2/error_log<br />
<span class="o">(</span>略<span class="o">)</span><br />
<span class="o">[</span>Tue Apr 23 21:46:14 2013<span class="o">]</span> <span class="o">[</span>error<span class="o">]</span> <span class="o">[</span>client ::1<span class="o">]</span> <span class="c">#!/bin/bash -xv</span><br />
<span class="o">[</span>Tue Apr 23 21:46:14 2013<span class="o">]</span> <span class="o">[</span>error<span class="o">]</span> <span class="o">[</span>client ::1<span class="o">]</span><br />
<span class="o">[</span>Tue Apr 23 21:46:14 2013<span class="o">]</span> <span class="o">[</span>error<span class="o">]</span> <span class="o">[</span>client ::1<span class="o">]</span> <span class="nb">echo</span> <span class="s2">&quot;Content-Type: text/html&quot;</span><br />
<span class="o">[</span>Tue Apr 23 21:46:14 2013<span class="o">]</span> <span class="o">[</span>error<span class="o">]</span> <span class="o">[</span>client ::1<span class="o">]</span> + <span class="nb">echo</span> <span class="s1">&#39;Content-Type: text/html&#39;</span><br />
<span class="o">[</span>Tue Apr 23 21:46:14 2013<span class="o">]</span> <span class="o">[</span>error<span class="o">]</span> <span class="o">[</span>client ::1<span class="o">]</span> <span class="nb">echo</span> <span class="s2">&quot;&quot;</span><br />
<span class="o">[</span>Tue Apr 23 21:46:14 2013<span class="o">]</span> <span class="o">[</span>error<span class="o">]</span> <span class="o">[</span>client ::1<span class="o">]</span> + <span class="nb">echo</span> <span class="s1">&#39;&#39;</span><br />
<span class="o">[</span>Tue Apr 23 21:46:14 2013<span class="o">]</span> <span class="o">[</span>error<span class="o">]</span> <span class="o">[</span>client ::1<span class="o">]</span> <span class="nb">echo</span> <span class="se">\\x</span>e9<span class="se">\\x</span>ad<span class="se">\\x</span>9a...<span class="o">(</span>略<span class="o">)</span><br />
</pre></div><br />
</td></tr></table></div><br />
<p>　今挙げたポイントは、別のLL言語でも全く同じ事です。<br />
違うのは、LL言語には便利なライブラリが存在していて、<br />
ウェブサーバとのダイレクトなやりとりがちょっとだけ隠蔽されていることです。<br />
でもまあ、何を使おうが普通のCGIの場合、<br />
最終的にはHTTPでHTMLやjavascriptを出力することになります。</p><br />
</div><br />
<div class="section" id="id2"><br />
<h2>19.4. とりあえず何か作ってみましょう<a class="headerlink" href="#id2" title="このヘッドラインへのパーマリンク">¶</a></h2><br />
<p>　さて、シェルスクリプトでCGIスクリプトが作れると分かったので、<br />
さっそくなにか作ってみましょう。<br />
実用的なものは次回以降にまわすとして、<br />
何か面白い物を作ってみましょう。</p><br />
<p>　まずは、端末からブラウザに文字等を送り込むものを作ってみます。<br />
リスト13のようなシェルスクリプトを作ります。</p><br />
<ul class="simple"><br />
<li>リスト13: <tt class="docutils literal"><span class="pre">notify.cgi</span></tt></li><br />
</ul><br />
<div class="highlight-bash"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1<br />
 2<br />
 3<br />
 4<br />
 5<br />
 6<br />
 7<br />
 8<br />
 9<br />
10</pre></div></td><td class="code"><div class="highlight"><pre>uedamac:cgi-bin ueda<span class="nv">$ </span>cat notify.cgi<br />
<span class="c">#!/bin/bash</span><br />
<br />
mkfifo /tmp/pipe<br />
chmod a+w /tmp/pipe<br />
<br />
<span class="nb">echo</span> <span class="s2">&quot;Content-Type: text/html&quot;</span><br />
<span class="nb">echo</span> <span class="s2">&quot;&quot;</span><br />
cat /tmp/pipe<br />
rm /tmp/pipe<br />
</pre></div><br />
</td></tr></table></div><br />
<p>4行目の <tt class="docutils literal"><span class="pre">mkfifo</span></tt> というコマンドは、<br />
「名前つきパイプ」という特別なファイルを作るコマンドです。<br />
「名前つきパイプ」は、その名のとおりパイプでして、<br />
片方から字を突っ込むと、もう片方から字が出てきます。<br />
例えば、</p><br />
<div class="highlight-bash"><div class="highlight"><pre><span class="nv">$ </span><span class="nb">echo </span>hoge | cat<br />
</pre></div><br />
</div><br />
<p>という処理を名前付きパイプで書くとリスト14のようになります。</p><br />
<ul class="simple"><br />
<li>リスト14: 名前付きパイプを使う</li><br />
</ul><br />
<div class="highlight-bash"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1<br />
2<br />
3<br />
4</pre></div></td><td class="code"><div class="highlight"><pre>//端末1<br />
<span class="nv">$ </span>cat /tmp/pipe<br />
//端末2<br />
<span class="nv">$ </span><span class="nb">echo </span>hoge &gt; /tmp/pipe<br />
</pre></div><br />
</td></tr></table></div><br />
<p>こうすると、端末1の <tt class="docutils literal"><span class="pre">cat</span></tt> は <tt class="docutils literal"><span class="pre">/tmp/pipe</span></tt><br />
に何か字が流れてくるまで止まった状態になり、<br />
端末2で <tt class="docutils literal"><span class="pre">echo</span> <span class="pre">hoge</span></tt> が実行されたら <tt class="docutils literal"><span class="pre">hoge</span></tt> と出力します。<br />
<tt class="docutils literal"><span class="pre">echo</span> <span class="pre">hoge</span></tt> が終わると、 <tt class="docutils literal"><span class="pre">cat</span></tt> も終わります。<br />
よくよく考えると、この動作は普通のパイプのものと同じです。<br />
ただし、 <tt class="docutils literal"><span class="pre">/tmp/pipe</span></tt> は <tt class="docutils literal"><span class="pre">rm</span></tt> で消さない限り、残ります。</p><br />
<p>　五行目の <tt class="docutils literal"><span class="pre">chmod</span></tt> は、 <tt class="docutils literal"><span class="pre">/tmp/pipe</span></tt><br />
の所有者以外でも書き込めるようにするためのパーミッション変更です。</p><br />
<p>　さて、 <tt class="docutils literal"><span class="pre">notify.cgi</span></tt> をブラウザから呼び出してみましょう。<br />
CGIスクリプトは <tt class="docutils literal"><span class="pre">cat</span> <span class="pre">/tmp/pipe</span></tt> で一旦止まるので、<br />
ブラウザでは待ちの状態になります。</p><br />
<p>　次に、おもむろに端末からリスト15のように打ってみてください。<br />
（脚注: <tt class="docutils literal"><span class="pre">/tmp/pipe</span></tt> のないときにやってしまうと、<br />
<tt class="docutils literal"><span class="pre">/tmp/pipe</span></tt> という普通のファイルができてしまうので注意してください。）</p><br />
<ul class="simple"><br />
<li>リスト15: 送り込む文字列</li><br />
</ul><br />
<div class="highlight-bash"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre>uedamac:~ ueda<span class="nv">$ </span><span class="nb">echo</span> <span class="s1">&#39;&lt;script&gt;alert(&quot;no more XSS!!&quot;)&lt;/script&gt;&#39;</span> &gt; /tmp/pipe<br />
</pre></div><br />
</td></tr></table></div><br />
<p>図3のようにアラートが出たら成功です。<br />
何の役にも立たないですが、多分、面白いと思っていただけたかと。</p><br />
<ul class="simple"><br />
<li>図3: ブラウザでアラートが表示される</li><br />
</ul><br />
<div class="figure"><br />
<a class="reference internal image-reference" href="http://blog.ueda.asia/wp-content/uploads/2014/12/ALERT.png"><img alt="" src="http://blog.ueda.asia/wp-content/uploads/2014/12/ALERT.png" style="width: 50%;" /></a><br />
</div><br />
<p>　ちなみに、HTTPヘッダがちゃんと意味があるということを示すために、<br />
<tt class="docutils literal"><span class="pre">notify.cgi</span></tt> をリスト2のように書き換えてもう一度やってみます。</p><br />
<ul class="simple"><br />
<li>リスト16: <tt class="docutils literal"><span class="pre">notify2.cgi</span></tt></li><br />
</ul><br />
<div class="highlight-bash"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1<br />
 2<br />
 3<br />
 4<br />
 5<br />
 6<br />
 7<br />
 8<br />
 9<br />
10</pre></div></td><td class="code"><div class="highlight"><pre>uedamac:cgi-bin ueda<span class="nv">$ </span>cat notify2.cgi<br />
<span class="c">#!/bin/bash</span><br />
<br />
mkfifo /tmp/pipe<br />
chmod a+w /tmp/pipe<br />
<br />
<span class="nb">echo</span> <span class="s2">&quot;Content-Type: text/plain&quot;</span><br />
<span class="nb">echo</span> <span class="s2">&quot;&quot;</span><br />
cat /tmp/pipe<br />
rm /tmp/pipe<br />
</pre></div><br />
</td></tr></table></div><br />
<p>今度は、ブラウザに<br />
「&lt;script&gt;alert(&#8220;no more XSS&#8221;)&lt;/script&gt;』<br />
と文字列が表示されたと思います。<br />
まともなブラウザならば・・・。</p><br />
<p>　HTTPヘッダの話が出たので、<br />
最後にファイルのダウンロードでもやってみましょう。<br />
例えばみんな大好きエクセルファイルのダウンロードを行うCGIスクリプトでは、<br />
リスト17のように書けます。</p><br />
<ul class="simple"><br />
<li>リスト17: ファイルをダウンロードさせるCGIスクリプト</li><br />
</ul><br />
<div class="highlight-bash"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1<br />
 2<br />
 3<br />
 4<br />
 5<br />
 6<br />
 7<br />
 8<br />
 9<br />
10<br />
11</pre></div></td><td class="code"><div class="highlight"><pre>uedamac:cgi-bin ueda<span class="nv">$ </span>cat download_xlsx.cgi<br />
<span class="c">#!/bin/bash -xv</span><br />
<br />
<span class="nv">FILE</span><span class="o">=</span>/tmp/book1.xlsx<br />
<span class="nv">LENGTH</span><span class="o">=</span><span class="k">$(</span>wc -c <span class="nv">$FILE</span> | awk <span class="s1">&#39;{print $1}&#39;</span><span class="k">)</span><br />
<br />
<span class="nb">echo</span> <span class="s2">&quot;Content-Type: application/octet-stream&quot;</span><br />
<span class="nb">echo</span> <span class="s1">&#39;Content-Disposition: attachment; filename=&quot;hoge.xlsx&quot;&#39;</span><br />
<span class="nb">echo</span> <span class="s2">&quot;Content-Length: $LENGTH&quot;</span><br />
<span class="nb">echo</span><br />
cat <span class="nv">$FILE</span><br />
</pre></div><br />
</td></tr></table></div><br />
<p>7行目の <tt class="docutils literal"><span class="pre">application/octet-stream</span></tt> は、<br />
「バイナリを送り込むぞ」という宣言、<br />
8行目は「 <tt class="docutils literal"><span class="pre">hoge.xlsx</span></tt> という名前で保存してくれ」、<br />
9行目は変数 <tt class="docutils literal"><span class="pre">LENGTH</span></tt> に書いてあるサイズのデータを出力するぞ、<br />
という意味になります。</p><br />
<p>　そして、実際にファイルをブラウザに向けて発射するのには、<br />
11行目のようにおなじみの <tt class="docutils literal"><span class="pre">cat</span></tt> を使います。<br />
<tt class="docutils literal"><span class="pre">cat</span></tt> はテキストもバイナリも区別しません。<br />
区別してしまうと他のコマンドと連携して使えなくなってしまいます。</p><br />
<p>　ファイルはありとあらゆるものがダウンロードさせることができますが、<br />
ヘッダについては微妙に変化させます。<br />
例えば、mpegファイルをブラウザに直接見せたいのなら図12のように書きます。</p><br />
<ul class="simple"><br />
<li>図12: mpegファイルを見せるためのCGIスクリプト</li><br />
</ul><br />
<div class="highlight-bash"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1<br />
 2<br />
 3<br />
 4<br />
 5<br />
 6<br />
 7<br />
 8<br />
 9<br />
10</pre></div></td><td class="code"><div class="highlight"><pre>uedamac:cgi-bin ueda<span class="nv">$ </span>cat download_movie.cgi<br />
<span class="c">#!/bin/bash</span><br />
<br />
<span class="nv">FILE</span><span class="o">=</span>/tmp/japanopen2006_keeper.mpeg<br />
<span class="nv">LENGTH</span><span class="o">=</span><span class="k">$(</span>wc -c <span class="nv">$FILE</span> | awk <span class="s1">&#39;{print $1}&#39;</span><span class="k">)</span><br />
<br />
<span class="nb">echo</span> <span class="s2">&quot;Content-Type: video/mpeg&quot;</span><br />
<span class="nb">echo</span> <span class="s2">&quot;Content-Length: $LENGTH&quot;</span><br />
<span class="nb">echo</span><br />
cat <span class="nv">$FILE</span><br />
</pre></div><br />
</td></tr></table></div><br />
<p>　私の普段使っているブラウザ（MacのGoogle ChromeとFirefox）では、<br />
図13のようにブラウザのプラグインが立ち上がり、<br />
画面内でムービーが再生されます。</p><br />
<ul class="simple"><br />
<li>図13: ヘッダを適切に書くとブラウザでよしなに取りはからってくれる</li><br />
</ul><br />
<div class="figure"><br />
<a class="reference internal image-reference" href="http://blog.ueda.asia/wp-content/uploads/2014/12/MOVIE.png"><img alt="" src="http://blog.ueda.asia/wp-content/uploads/2014/12/MOVIE.png" style="width: 30%;" /></a><br />
</div><br />
<p>ヘッダに <tt class="docutils literal"><span class="pre">Content-Disposition:</span> <span class="pre">attachment;</span> <span class="pre">filename=&quot;hoge.mpeg&quot;'</span></tt><br />
を加えると、ファイルを再生するかファイルに保存するか聞いて来たり、<br />
再生されずにファイルに保存されたりします。<br />
筆者のHTTPヘッダについての知識はこの程度ですが、<br />
もし別の言語でHTTPヘッダを間接的にいじったことのある人は、<br />
シェルスクリプトでも細かい制御ができることでしょう。</p><br />
</div><br />
<div class="section" id="id3"><br />
<h2>19.5. おわりに<a class="headerlink" href="#id3" title="このヘッドラインへのパーマリンク">¶</a></h2><br />
<p>　今回はシェルスクリプトでCGIスクリプトを書きました。<br />
特に出力について扱いました。<br />
おそらく今回の内容で一番重要なのは、<br />
apacheを経由してブラウザにコンテンツを送るときには、<br />
標準出力を使うということでしょうか。<br />
ここらあたりにも、インターネットがUNIXと共に発展して来た名残があります。<br />
いや、名残というよりも必然かもしれません。<br />
標準入出力は、これ以上ないくらい抽象化されたインタフェースであり、<br />
まず最初に使用を検討すべきものでしょう。</p><br />
<p>　次回はCGIスクリプトでのPOST、<br />
GETも絡めて何かを作ってみようと考えています。</p><br />
</div><br />
</div>
